
/*
	题意：给定货币 c1,c5,c10,c20,c50,c100,c200,c500,c1000,c2000 个数，求组合成 p 的最多货币数。
	题解：贪心 + 搜索 
	1）尽量让面额小的多拿；
	2）从小到大拿，开始取 c10 之前，要求剩下的是10的倍数，否则一定组合不出来；
	3）如果剩下的货币数之和已经小于需要组合的数，则返回 
*/
#include <iostream>

using namespace std;

#define maxn 10

int c[maxn], s[maxn+1];
const int b[maxn] = {1, 5, 10, 20, 50, 100, 200, 500, 1000, 2000}; 
const int m[maxn] = {1, 5, 10, 10, 50, 100, 100, 500, 1000, 2000};

int Min(int a, int b) {
	return a < b ? a : b;
}
int totalAns, ansCnt;

/* 
10 20 50
6   6  6

组成 110，  10*6 + 20*0 + 50*1 = 110   
            10*5 + 20*3 + 50*0 = 110  更优    
    
    所以，对于 100 以前的钱币，每个钱币需要搜索两次，确保对应剩余系的奇偶性都满足搜索条件 
*/

int dfs(int index, int curcap, int ans) {
    if(curcap == 0) {
        return ans;
    }
    if(index >= maxn || curcap < 0 || curcap > s[index]) {
        return -1;
    }
    if(curcap % m[index]) {
        return -1;
    }
    int start = Min(curcap / b[index], c[index]);
    int minans = -1;
    int anscnt = 0;
    for(int i = start; i >= 0; --i) {
        int v = dfs(index+1, curcap - i * b[index], ans + i);
        if( v == -1) {
            continue;
        }
        ++anscnt;
        if(v > minans) {
            minans = v;
        }    
        if(index <= 5) {
            if(anscnt >= 2) 
                break;            
        }    else {
            break;
        }
    }
    return minans;
}


int main() {
    int t;
    int i, p;
    scanf("%d", &t);
    
    while(t--) {
        scanf("%d", &p);
        s[maxn] = 0;
        for(i = 0; i < maxn; ++i) {
            scanf("%d", &c[i]); 
            s[i] = b[i] * c[i];
        }
        for(i = maxn - 1; i >= 0; --i) {
            s[i] += s[i+1];
        }
        printf("%d\n", dfs(0, p, 0) );
    } 
    
    return 0;
} 

/*
100000
17 8 4 2 0 0 0 0 0 0 0
100 99 0 0 0 0 0 0 0 0 0
2015 9 8 7 6 5 4 3 2 1 0
99999999 100000 100000 100000 100000 100000 100000 100000 100000 100000 100000
9999999 100000 100000 100000 100000 100000 100000 100000 100000 100000 100000
999999 100000 100000 100000 100000 100000 100000 100000 100000 100000 100000
99999 100000 100000 100000 100000 100000 100000 100000 100000 100000 100000
9999 100000 100000 100000 100000 100000 100000 100000 100000 100000 100000
999 100000 100000 100000 100000 100000 100000 100000 100000 100000 100000
99 100000 100000 100000 100000 100000 100000 100000 100000 100000 100000
9 100000 100000 100000 100000 100000 100000 100000 100000 100000 100000

9 8 4 2 0 0 0 0 0 0 0
17 8 4 2 0 0 0 0 0 0 0

1 8 4 2 0 0 0 0 0 0 0
2 8 4 2 0 0 0 0 0 0 0
7 8 4 2 0 0 0 0 0 0 0
8 8 4 2 0 0 0 0 0 0 0
9 8 4 2 0 0 0 0 0 0 0
10 8 4 2 0 0 0 0 0 0 0
11 8 4 2 0 0 0 0 0 0 0
12 8 4 2 0 0 0 0 0 0 0
13 8 4 2 0 0 0 0 0 0 0
20 8 4 2 0 0 0 0 0 0 0
22 8 4 2 0 0 0 0 0 0 0
27 8 4 2 0 0 0 0 0 0 0
29 8 4 2 0 0 0 0 0 0 0
28 8 4 2 0 0 0 0 0 0 0
30 8 4 2 0 0 0 0 0 0 0
31 8 4 2 0 0 0 0 0 0 0
40 8 4 2 0 0 0 0 0 0 0
45 8 4 2 0 0 0 0 0 0 0
46 8 4 2 0 0 0 0 0 0 0
47 8 4 2 0 0 0 0 0 0 0
48 8 4 2 0 0 0 0 0 0 0

388599999 100000 100000 100000 100000 100000 100000 100000 100000 100000 100000


小数据

10000

2011 9 8 7 6 5 4 3 2 2 1
2151 9 8 7 6 5 4 3 2 2 1
2100 0 0 6 6 5 4 3 2 2 1
100 0 0 6 6 6 0 0 0 0 0
110 0 0 6 6 6 0 0 0 0 0
120 0 0 6 6 6 0 0 0 0 0
130 0 0 6 6 6 0 0 0 0 0
140 0 0 6 6 6 0 0 0 0 0
150 0 0 6 6 6 0 0 0 0 0


*/






