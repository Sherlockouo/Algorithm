#### 题意
* 给定一个字符串A和值n，m，n代表字符串A的长度，求字符串B满足以下条件：
* 1）B 和 A 的哈明距离正好是 m；
* 2）B 是一个平方串；
* 3）B 的字典序最小；
* 其中哈明距离就是两个长度相同字符串，对应位置的不同字符的个数；平方串的定义是它是 XX 类型的字符串，即 "abcdabcd", "KlKl";

#### 题解
* BFS + 路径构造

#### 题目分析
* 1、因为 B 要求是平方串，所以 strlen(A) 一定是偶数，否则无解；
* 2、B 的每个字符的取值独立，为 [a-z] 26 种情况；
* 3、有如下表格：

-|a|b|c|d|e|f|g|h|i|j|-
-|-|-|-|-|-|-|-|-|-|-|-
a|-|-|-|-|-|-|-|-|-|-|-
b|-|-|-|-|-|-|-|-|-|-|-
c|1|2|1|2|2|2|2|2|2|2|-
d|2|1|2|1|2|2|2|2|2|2|-

* "abcd" 这个字符串，在B的取值分别为 a、b、c、d... 的时候，对应位置贡献的哈明距离的值；我们发现，a和c的贡献都是1，而我们要求 B 的字典序最小，那么很明显，这里我们肯定没必要选 c， a 一定优于 c；
* 4、用 visit[n/2][n] 表示状态进行广搜；其中 visit[i][j] 表示前i个字符组合得到的哈明距离总和为j的状态是否有被访问到，状态扩展是个二叉树，比如 aaab，在选择第一个字符的时候一定是 a或b，在选择第二个字符的时候一定是 a或c；
* 5、从初始状态 visit[0][0] 搜索到 visit[n/2][m] ，记录每个状态的前驱状态，然后逆序输出即可；
