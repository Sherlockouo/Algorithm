#### 题意
* N ( N <= 200 ) 个方块排成一排，每个方块一种颜色，每次可以选择其中一种连续的颜色块进行消除，消除的分数为色块长度的平方，求最后全部色块消除的总分，要求这个最大值；

![image](http://poj.org/images/1390_2.jpg)

##### 输入
* 9
* 1 2 2 2 2 3 3 3 1
##### 输出
* 29（4^2^+3^2^+2^2^）

#### 题解
* 记忆化搜索/区间 DP

#### 题目分析
* 预处理输入，将相同颜色的方块归并，color[i] 表示第i种方块的颜色，num[i] 表示第i种方块的数量；
* 令 dp[i][j][k] 表示 [i, j] 消掉，并且第 j 个块连同后面 k 个块消去的最大分数；
* 1）第j个块单独和后面的k个块消掉，那么分数为 dp[i][j-1][0] + (num[j]+k)^2^ ；
* 2）对于 s 属于 [i, j)，如果 color[s] == color[j]，则有
```math
    dp[i][s][ num[j]+k ] + dp[s+1][j-1][0];
```

-|1|2|3|4|5
-|-|-|-|-|-
颜色|C3|C2|C4|C2|C4
个数|3|4|2|9|2

```
    graph LR;
    
    颜色  --> A
    A(C3) --> B
    B(C2) --> C
    C(C4) --> D
    D(C2) --> E(C4)
    
    
    个数 --> a
    a(3) --> b
    b(4) --> c
    c(2) --> d
    d(9) --> e(2)
    
```

> 对 2）的解释：如果中间某个块(index = s)和最后的那个块(index = j)的颜色相同，那么如果我们要把他们在后续归并到一起，势必中间的(s, j) 这块要单独计算，即 dp[s+1][j-1][0]；并且，为[i,s]这个区间增加了 num[j]+k 个和 index=s 的块的个数，即 dp[i][s][ num[j]+k ]；
